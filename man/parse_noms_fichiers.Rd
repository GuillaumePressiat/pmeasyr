% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/archives.R
\name{parse_noms_fichiers}
\alias{parse_noms_fichiers}
\title{Extraire les informations d'un nom de fichier}
\usage{
parse_noms_fichiers(noms_fichiers, return_tibble = TRUE)
}
\arguments{
\item{noms_fichiers}{Des noms de fichiers d'archive sous la forme d'un vecteur de caractères.}

\item{return_tible}{Retourne une table si \code{TRUE}, sinon retourne une liste.}
}
\value{
Une liste ou une table avec les informations extraites du nom de fichier :
\itemize{
\item \code{nom_fichier} Le nom de fichier passé en arguement
\item \code{finess}
\item \code{annee}
\item \code{mois}
\item \code{horodatage_production} L'horodatage de production pour les fichiers \emph{in} et \emph{out} au format POSIXlt
Si il y a plusieurs fichiers, la liste peut être facilement transformée en table avec \code{\link[dplyr:bind_rows]{dplyr::bind_rows()}}.
\item \code{type} Type de fichier : \emph{in}, \emph{out}, \emph{rss}...
}
}
\description{
Les noms de fichiers des archives PMSI ont toujours le même format, de la forme \emph{finess.annee_envois.mois_envois.} suivi par \emph{horodatage} pour les archives \emph{in} et \emph{ou} et enfin le \emph{type} de fichier. Cette fonction permet d'extraire cette information.
}
\examples{
noms_de_fichiers <- c("671234567.2016.1.12032016140012.in.zip",
                      "671234567.2016.1.rum.txt")
 x <- parse_noms_fichiers(noms_de_fichiers)
dplyr::bind_rows(x)
}
